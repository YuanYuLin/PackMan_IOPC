import json
import sys
import os
from subprocess import call
import struct
import ConfigParser

def execmd(cmd):
    print cmd
    return call(cmd)

def help():
    '''
    print "gen_image.py build <layout.json> <dest storage device> <out bins> <output bsp dir> <output rootfs dir>"
    print "  ex: gen_image.py build dao.ini /dev/sdd output/outbins output/bsp_armel/arm/arch output/rootfs_armel/arm_arch"
    print "gen_image.py scratch <layout.json> <dest storage device> <output bins>"
    print "  ex: gen_image.py scratch dao.ini /dev/sdd"
    print "  <action>:"
    print "        build        - build from source pool"
    print "        scratch      - build from scratch files"
    '''
    print "gen_image.py <layout.json> <dest storage device> <output bsp dir> <output rootfs dir>"
    print "  ex: gen_image.py dao.ini /dev/sdd output/bsp_armel/arm/arch output/rootfs_armel/arm_arch"
    sys.exit(1)

def setLibPath():
    # append library path
    python_lib = os.path.abspath("pylib")
    sys.path.append(python_lib)

    if not os.path.exists(python_lib):
        print "Please download [pylib] from github!!"
        print "git clone https://github.com/YuanYuLin/pylib.git"
        sys.exit(1)

    sys.path.append(python_lib)
    python_lib = os.path.abspath("pyiopc")
    sys.path.append(python_lib)

def head_to_binary(pack):
    data = bytearray('\0' * 64)
    idx = 0
    for ch in bytearray(pack):
        data[idx] = ch
        idx += 1
    return data

def size_to_bytes(size_str):
    val = 0
    if size_str[-1:] == 'B':
        val = int(size_str[0:-1])
    elif size_str[-1:] == '%':
        val = 0xFFFFFFFF
    return val

def create_header(layout_obj):
    header = bytearray('\0' * (64 *1024))
    '''
    buffers = []
    version = 1
    table_type = str(layout_obj["table_type"])
    platform = str(layout_obj["platform"])
    platform_id = layout_obj["platform_id"]
    print table_type, platform, platform_id
    pack = struct.pack("12sI20sI12s", "$[IOPCHEAD]$".ljust(12), version, platform.ljust(20), platform_id, table_type.ljust(12))
    buffers.append(head_to_binary(pack))
    for part in layout_obj["parts"]:
        obj = layout_obj[part]
        part_name = str(part)
        boot=obj["boot"]
        fstype = str(obj["fstype"])
        start = size_to_bytes(obj["start"])
        end = size_to_bytes(obj["end"])

        bin_file = obj["bin_files"]
        pack = struct.pack("12s10s10sQQB", "$[IOPCREC]$".ljust(12), part_name.ljust(10), fstype.ljust(10), start, end, boot)
        buffers.append(head_to_binary(pack))

    pack = struct.pack("12sI20sI12s", "$[IOPCEND]$".ljust(12), version, platform.ljust(20), platform_id, table_type.ljust(12))
    buffers.append(head_to_binary(pack))
    idx = 0
    for sec in buffers:
        for ch in sec:
            header[idx]=ch
            idx+=1
    '''
    header[0]='['
    header[1]='*'
    header[2]='I'
    header[3]='O'
    header[4]='P'
    header[5]='C'
    header[6]='*'
    header[7]=']'

    return header

def is_file_exist(binfile, output_dir):
    print os.path.join(output_dir, binfile)
    if os.path.exists(os.path.join(output_dir, binfile)):
        return True
    return False

def read_file(binfile, output_dir):
    data = None
    with open(os.path.join(output_dir, binfile), "rb") as bin_file:
        data = bin_file.read()
    return data

def overwrite_to(offset, src, dst):
    fp = open(dst, "r+b")
    fp.seek(offset)
    fp.write(src)
    fp.close()

def gen_grub_cfg(grub_cfg):
    blkid = "53C9-A75B"
    with open(grub_cfg, "w") as fp: 
        fp.write("#\n")
        fp.write("# DO NOT EDIT THIS FILE\n")
        fp.write("#\n")
        fp.write("# It is automatically generated by grub-mkconfig using templates\n")
        fp.write("# from /etc/grub.d and settings from /etc/default/grub\n")
        fp.write("#\n")

        fp.write("set have_grubenv=true\n")
        fp.write("load_env\n")

        fp.write("function load_video {\n")
        fp.write("insmod all_video\n")
        fp.write("}\n")

        fp.write("set timeout=2\n")

        fp.write("menuentry 'IOPC' {\n")
        fp.write("load_video\n")
        fp.write("insmod gzio\n")
        fp.write("insmod part_msdos\n")
        fp.write("insmod ext2\n")
        fp.write("set root='hd0,msdos1'\n")
        fp.write("search --no-floppy --fs-uuid --set=root %s\n" % blkid)
        fp.write("echo    'Loading Linux Image ...'\n")
        fp.write("linux /linux_image root=UUID=%s init=/bin/sh BOOT_DELAY=3 BOOT_DEV=/dev/sda BOOT_DEV_PART=1 BOOT_ROOTFS=rootfs.squashfs BOOT_ON_RAM=y\n" % blkid)
        fp.write("}\n")

def copy_files_to_bins(bsp_dir, rootfs_dir, bins_dir):
    rst = execmd(['sudo', 'mkdir', '-p', bins_dir])
    rst = execmd(['sudo', 'cp', '-avr', os.path.join(bsp_dir, 'kmod.squashfs'), bins_dir])
    rst = execmd(['sudo', 'cp', '-avr', os.path.join(bsp_dir, 'linux_image'), bins_dir])
    rst = execmd(['sudo', 'cp', '-avr', os.path.join(bsp_dir, 'env.txt'), bins_dir])
    rst = execmd(['sudo', 'cp', '-avr', os.path.join(rootfs_dir, 'rootfs.squashfs'), bins_dir])
    rst = execmd(['sudo', 'cp', '-avr', os.path.join(rootfs_dir, 'dao.squashfs'), bins_dir])
    #rst = execmd(['sudo', 'cp', '-avr', os.path.join(rootfs_dir, 'db_init.bin'), bins_dir])
    #rst = execmd(['sudo', 'cp', '-avr', os.path.join(rootfs_dir, 'img_header.bin'), bins_dir])
    rst = execmd(['sudo', 'cp', '-avr', os.path.join(rootfs_dir, 'platform'), bins_dir])
    rst = execmd(['sudo', 'cp', '-avr', os.path.join(rootfs_dir, 'env.txt'), bins_dir])

def mkfs_and_copy_bins(bins_dir, off_start, storage_dev, bin_files, fstype, bootable):
    part_dev = '/dev/loop7'
    mount_dir = '/mnt'
    mount_boot_dir = '/mnt/boot'
    mount_boot_grub_dir = '/mnt/boot/grub'
    print "Losetup " + storage_dev + " To " + part_dev
    rst = execmd(['sudo', 'losetup', '-o', str(off_start), part_dev, storage_dev])
    print rst
    print "------------------------"
    print "Mkfilesystem " + part_dev + " As " + fstype
    rst = execmd(['sudo', 'mkfs', '-t', fstype, part_dev])
    print rst
    print "------------------------"
    print "Mount " + part_dev + " To " + mount_dir + " As " + fstype
    rst = execmd(['sudo', 'mount', '-t', fstype, part_dev, mount_dir])
    print rst
    print "------------------------"
    if bootable :
        print "Install GRUB " + part_dev + " To " + mount_dir + " As " + fstype
        rst = execmd(['sudo', 'mkdir', '-p', mount_boot_dir])
        #rst = execmd(['sudo', 'blkid', part_dev])
        #rst = execmd(['sudo', 'grub-install', '--no-floppy', '--boot-directory=' + mount_boot_dir, storage_dev])
        #print ['sudo', 'grub-install', '--compress=xz', '--force', '--no-floppy', '--boot-directory=' + mount_boot_dir, storage_dev]
        print ['sudo', 'grub-install', '--force', '--no-floppy', '--boot-directory=' + mount_boot_dir, storage_dev]
        rst = execmd(['sudo', 'mkdir', '-p', mount_boot_grub_dir])
        gen_grub_cfg("/tmp/grub.cfg")
        rst = execmd(['sudo', 'cp', "/tmp/grub.cfg", mount_boot_grub_dir])
        print "------------------------"

    for bin_file in bin_files:
        print "* Try to Copy " + os.path.join(bins_dir, bin_file) + " To " + mount_dir
        if is_file_exist(bin_file, bins_dir):
            rst = execmd(['sudo', 'cp', os.path.join(bins_dir, bin_file), mount_dir])
            print rst
            print "* Copy " + os.path.join(bins_dir, bin_file) + " To " + mount_dir
            print "------------------------"

    execmd(['sudo', 'umount', mount_dir])
    execmd(['sudo', 'losetup', '-d', part_dev])

if __name__ == '__main__':
    setLibPath()
    print len(sys.argv)
    if len(sys.argv) < 2:
        help()

    action = sys.argv[1]
    dao_ini = sys.argv[2]
    storage_dev = sys.argv[3]
    bins_dir = sys.argv[4]

    if action == "scratch":
        print "scratch"
    elif action == "build":
        print "build"
        bsp_dir = sys.argv[5]
        rootfs_dir = sys.argv[6]
        copy_files_to_bins(bsp_dir, rootfs_dir, bins_dir)
    else:
        sys.exit(1)

    config = ConfigParser.ConfigParser()
    config.read(dao_ini)
    layout = config.get('CFG_IMAGE', 'layout')
    layout_obj  = json.loads(layout)
    table_type = layout_obj["table_type"]

    if table_type == "gpt":
        print "GPT"
    elif table_type == "msdos":
        print "MBR"
    else:
        print "Table type not supported " + table_type
        sys.exit(1)

    execmd(['sudo', 'parted', storage_dev, 'mktable', table_type])

    '''
    print "Creating header..."
    header_bin = create_header(layout_obj)
    print "Write to dev", storage_dev
    overwrite_to((1024*1024), header_bin, storage_dev)
    '''

    print "Creating partition"
    part_index = 0
    parts = layout_obj["parts"]
    for part in parts:
        obj = layout_obj[part]
        fstype = obj["fstype"]
        fs_start = obj["start"]
        fs_end = obj["end"]
        fs_boot = obj["boot"]
        bin_files = obj["bin_files"]
        if (fstype == "iopcdao") or (fstype == "iopcdaobk"):
            print "iopcdao"
            off_start = int(fs_start[0:-1], 10)
            off_end = int(fs_end[0:-1],10)
            for bin_file in bin_files:
                bin_data = None
                if is_file_exist(bin_file, bins_dir):
                    bin_data = read_file(bin_file, bins_dir)

                if bin_data != None :
                    print off_start, off_end
                    overwrite_to(off_start, bin_data, storage_dev)
        elif fstype == "fat32":
            print "fat32" 
            off_start = int(fs_start[0:-1], 10)
            off_end = int(fs_end[0:-1],10)
            execmd(['sudo', 'parted', storage_dev, 'mkpart', 'primary', 'fat32', fs_start, fs_end])
            mkfs_and_copy_bins(bins_dir, off_start, storage_dev, bin_files, 'vfat', 1)
            part_index += 1
        elif fstype == "ext4":
            print "ext4"
            off_start = int(fs_start[0:-1], 10)
            off_end = int(fs_end[0:-1],10)
            execmd(['sudo', 'parted', storage_dev, 'mkpart', 'primary', 'ext4', fs_start, fs_end])
            mkfs_and_copy_bins(bins_dir, off_start, storage_dev, bin_files, 'ext4', 0)
            part_index += 1
        elif fstype == "empty":
            print "empty"
            off_start = int(fs_start[0:-1], 10)
            off_end = int(fs_end[0:-1], 10)
            execmd(['sudo', 'parted', storage_dev, 'mkpart', 'primary', 'fat32', fs_start, fs_end])
            print "Creating header..."
            header_bin = create_header(layout_obj)
            print "Write to dev", storage_dev
            overwrite_to((1024*1024), header_bin, storage_dev)
        else:
            print "Fstype not supported " + fstype

        if fs_boot == 1 :
            print "Fsboot " + str(part_index)
            execmd(['sudo', 'parted', storage_dev, 'set', str(part_index), 'boot', 'on'])

    #print layout_obj
    #print storage_dev
    #print dao_bin_file
